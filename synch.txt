Synchronization Design Document for ext2 File System Operations
================================================================

Overview
--------
This document describes the synchronization strategy used to ensure thread-safe
concurrent access to the ext2 file system data structures. The design uses an
OPTIMISTIC LOCKING approach combined with fine-grained locks to maximize 
concurrency while preventing race conditions and deadlocks.

Key Design Principle: Optimistic Locking
----------------------------------------
The synchronization strategy follows an optimistic locking pattern:

1. OPTIMISTIC PHASE (Lock-Free): Perform initial lookups, path resolution,
   and validation checks WITHOUT holding any locks. This allows maximum
   concurrency during the read-heavy portion of operations.

2. VALIDATION PHASE (Locked): After acquiring the necessary locks, RE-VERIFY
   all conditions that were checked during the optimistic phase. This catches
   any concurrent modifications that occurred between the initial check and
   lock acquisition.

3. MODIFICATION PHASE (Locked): Apply changes while holding appropriate locks.

4. CLEANUP: If validation fails, release locks and return appropriate error.

This approach is more efficient than pessimistic locking because:
- Most operations succeed without contention
- Locks are held for minimal time
- Failed operations don't waste resources on rollback

Shared Data Structures
----------------------
The following data structures are shared among concurrent file system operations:

1. Superblock (superblock): Contains file system metadata including free block
   and inode counts.

2. Group Descriptor (group_desc): Contains block group metadata including
   free counts and directory count.

3. Inode Bitmap (inode_bitmap): Bitmap tracking allocated/free inodes.

4. Block Bitmap (block_bitmap): Bitmap tracking allocated/free blocks.

5. Inode Table (inode_table): Array of all inodes in the file system.

6. Data Blocks: Actual data blocks on the disk, accessed via mmap.

Synchronization Primitives
--------------------------
We use the following locks to protect shared data:

1. inode_bitmap_lock (pthread_mutex_t):
   - Protects the inode bitmap and inode-related counts in superblock/group_desc
   - Must be held when allocating or freeing inodes
   - Held only briefly during bitmap operations

2. block_bitmap_lock (pthread_mutex_t):
   - Protects the block bitmap and block-related counts in superblock/group_desc
   - Must be held when allocating or freeing blocks
   - Held only briefly during bitmap operations

3. inode_locks[] (array of pthread_mutex_t):
   - One lock per inode (indexed by inode number - 1)
   - Protects individual inode structure contents
   - Used during validation phase to re-check conditions

4. block_locks[] (array of pthread_mutex_t):
   - One lock per block (indexed by block number - 1)
   - Protects individual block contents
   - Used when modifying directory entries within a block

Race Condition Handling
-----------------------

1. TWO CONCURRENT MKDIR REQUESTS for same path (e.g., mkdir "/foo" x2):
   
   Strategy: add_dir_entry() implements optimistic locking with re-verification
   
   - Thread A: Checks if "/foo" exists (not found), allocates inode/block
   - Thread B: Same checks, allocates different inode/block
   - Thread A: Acquires parent inode lock, RE-CHECKS if "foo" exists
     - If still not found: creates entry, succeeds
   - Thread B: Acquires parent inode lock, RE-CHECKS if "foo" exists
     - Now found (created by A): returns EEXIST, frees allocated resources
   
   Implementation in add_dir_entry():
     mutex_lock(&inode_locks[parent_inode - 1]);
     // re-verify: check if name already exists after acquiring lock
     int existing = find_dir_entry(dir_inode, name);
     if (existing >= 0) {
         mutex_unlock(&inode_locks[parent_inode - 1]);
         return EEXIST;
     }

2. DELETE /foo WHILE RUNNING mkdir /foo/bar:
   
   Strategy: add_dir_entry() re-verifies parent is still valid
   
   - Thread A: mkdir /foo/bar - looks up /foo, gets inode
   - Thread B: rm /foo or rmdir - starts deletion
   - Thread A: Tries to add "bar" to /foo
     - Acquires /foo's inode lock
     - RE-VERIFIES /foo is still a valid directory (checks i_mode)
     - If parent was deleted/corrupted: returns ENOENT
   
   Implementation in add_dir_entry():
     mutex_lock(&inode_locks[parent_inode - 1]);
     // re-verify: parent is still a valid directory after acquiring lock
     if (!S_ISDIR(dir_inode->i_mode)) {
         mutex_unlock(&inode_locks[parent_inode - 1]);
         return ENOENT;
     }

3. HARD LINK TO CONCURRENTLY DELETED FILE:
   
   Strategy: ln_hl locks source inode and re-verifies before incrementing link count
   
   - Thread A: ln_hl /file /link - looks up /file, gets source inode
   - Thread B: rm /file - starts deletion, decrements link count
   - Thread A: Before creating link
     - LOCKS source inode FIRST (prevents deletion from completing)
     - RE-VERIFIES source inode is still valid:
       * checks links_count > 0
       * checks dtime == 0 (not deleted)
       * checks not a directory
     - If valid: increments link count, then adds directory entry
     - If invalid (deleted): returns ENOENT
   
   Implementation in ext2_fsal_ln_hl():
     mutex_lock(&inode_locks[src_ino - 1]);
     // re-verify source inode is still valid after acquiring lock
     if (src_inode->i_links_count == 0 || src_inode->i_dtime != 0) {
         mutex_unlock(&inode_locks[src_ino - 1]);
         return ENOENT;
     }
     // increment BEFORE releasing lock (prevents deletion race)
     src_inode->i_links_count++;
     mutex_unlock(&inode_locks[src_ino - 1]);
     // now safe to add directory entry

4. CONCURRENT REMOVE with NAME CHANGE:
   
   Strategy: rm uses the inode found DURING locked search, not initial lookup
   
   - rm operation searches for entry BY NAME while holding parent lock
   - Uses found_target_ino from the locked search, not the pre-lookup
   - Re-verifies target is not a directory before removal
   
   Implementation in ext2_fsal_rm():
     mutex_lock(&inode_locks[parent_ino - 1]);
     // search and remove by NAME, storing actual inode found
     found_target_ino = entry->inode;
     // re-verify: check if the found entry is a directory
     if (S_ISDIR(found_inode->i_mode)) {
         // cannot remove directories with rm
         return EISDIR;
     }

LOCK ACQUISITION STRATEGY
-------------------------

Lock Usage
~~~~~~~~~~
The list below describes when each lock is required:

Inode Bitmap Lock (inode_bitmap_lock):
  Used in:
    - alloc_inode(): Lock -> find free inode -> mark used -> update counts -> unlock
    - free_inode(): Lock -> mark free -> update counts -> unlock
  Purpose: Protects inode bitmap and free inode counts in superblock/group_desc.
  Always held only briefly (non-nested).

Block Bitmap Lock (block_bitmap_lock):
  Used in:
    - alloc_block(): Lock -> find free block -> mark used -> update counts -> unlock
    - free_block(): Lock -> mark free -> update counts -> unlock
  Purpose: Protects block bitmap and free block counts.
  Also held briefly (non-nested).

Per-Inode Locks (inode_locks[]):
  Held when:
    - Reading/modifying any inode fields (e.g., links_count, i_mode)
    - Writing new inode metadata via write_inode()
    - Changing link counts in ln_hl, rm, mkdir
    - Validating inode state after optimistic lookup
  Index: inode_locks[inode_number - 1]

Per-Block Locks (block_locks[]):
  Held during:
    - Writing or updating file/directory data via write_block()
    - Modifying directory entries (adding/removing entries in add_dir_entry, rm)
    - Initializing new directory blocks
  Index: block_locks[block_number - 1]

Lock Ordering (Deadlock Prevention)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The actual lock ordering varies by operation, but follows these principles:

1. BITMAP LOCKS are always non-nested and brief:
   - Never held while acquiring inode or block locks
   - Acquired and released atomically within alloc/free functions

2. For DIRECTORY OPERATIONS (add_dir_entry, rm):
   - Parent directory inode lock FIRST
   - Parent directory data block locks SECOND (while holding parent inode lock)
   - Unlock in reverse order: block first, then parent inode

3. TARGET INODE is locked SEPARATELY (not nested with parent):
   - In rm: Parent is fully unlocked before locking target inode
   - In mkdir: Parent lock for link count update is separate from add_dir_entry

4. SPECIAL CASE for ln_hl:
   - Source inode lock FIRST (to prevent deletion race)
   - Unlock source BEFORE calling add_dir_entry
   - Parent locks handled independently by add_dir_entry

Unlocking Strategy
~~~~~~~~~~~~~~~~~~
We unlock immediately after finishing with each resource:
- Block locks released before parent inode lock (reverse order)
- No circular dependencies because:
  * Bitmap locks never overlap with inode/block locks
  * Target inode locked only after parent is released (in rm)
  * ln_hl releases source lock before acquiring parent locks

Operation-Specific Synchronization (with explicit lock names)
-------------------------------------------------------------

ext2_fsal_mkdir:
1. OPTIMISTIC PHASE (NO LOCKS):
   - Parse path, call path_lookup() for parent
   - Call find_dir_entry() to check if name exists
   
2. ALLOCATE (BITMAP LOCKS - brief, non-nested):
   - alloc_inode(): inode_bitmap_lock held briefly
   - alloc_block(): block_bitmap_lock held briefly
   
3. PREPARE (NO LOCKS - new resources not yet visible):
   - Initialize new_inode struct in local memory
   - write_inode(new_ino, &new_inode): acquires inode_locks[new_ino-1] briefly
   - write_block(new_block, block_buf): acquires block_locks[new_block-1] briefly
   
4. ADD ENTRY via add_dir_entry() (NESTED LOCKS):
   - Acquires: inode_locks[parent_ino-1]
   - Re-verifies: parent is directory, name doesn't exist
   - Acquires: block_locks[block_num-1] (while holding parent inode lock)
   - Modifies directory block
   - Releases: block_locks[block_num-1]
   - Releases: inode_locks[parent_ino-1]
   
5. UPDATE PARENT LINK COUNT (SINGLE LOCK):
   - Acquires: inode_locks[parent_ino-1]
   - Increments parent->i_links_count
   - Releases: inode_locks[parent_ino-1]

6. ON FAILURE - CLEANUP (BITMAP LOCKS):
   - free_block(): block_bitmap_lock held briefly
   - free_inode(): inode_bitmap_lock held briefly

ext2_fsal_ln_hl:
1. OPTIMISTIC PHASE (NO LOCKS):
   - path_lookup(src) to find source inode
   - Check source is not a directory
   - split_parent_name(dst) and path_lookup(parent)
   - find_dir_entry() to check if dest name exists
   
2. VALIDATE & INCREMENT SOURCE (SINGLE LOCK):
   - Acquires: inode_locks[src_ino-1]
   - Re-verifies: links_count > 0, dtime == 0, not a directory
   - Increments: src_inode->i_links_count (preemptive)
   - Releases: inode_locks[src_ino-1]
   
3. ADD ENTRY via add_dir_entry() (NESTED LOCKS):
   - Acquires: inode_locks[parent_ino-1]
   - Re-verifies: parent is directory, name doesn't exist
   - Acquires: block_locks[block_num-1] (nested)
   - Adds directory entry
   - Releases: block_locks[block_num-1]
   - Releases: inode_locks[parent_ino-1]
   
4. ON FAILURE - ROLLBACK (SINGLE LOCK):
   - Acquires: inode_locks[src_ino-1]
   - Decrements: src_inode->i_links_count
   - Releases: inode_locks[src_ino-1]

ext2_fsal_rm:
1. OPTIMISTIC PHASE (NO LOCKS):
   - split_parent_name() and path_lookup(parent_path)
   - find_dir_entry() to find target inode
   - Check target is not a directory
   
2. LOCK PARENT AND SEARCH (NESTED LOCKS):
   - Acquires: inode_locks[parent_ino-1]
   - Re-verifies: parent is still a directory
   - For each block in parent directory:
     - Acquires: block_locks[block_num-1] (nested with parent inode lock)
     - Searches for entry by NAME
     - If found: re-verify not a directory, remove entry
     - Releases: block_locks[block_num-1]
   - Releases: inode_locks[parent_ino-1]
   
3. UPDATE TARGET (SINGLE LOCK - AFTER parent released):
   - Acquires: inode_locks[found_target_ino-1]
   - Decrements: i_links_count
   - If links_count == 0:
     - Sets i_dtime
     - Calls free_block() for each data block (block_bitmap_lock - brief, while holding target inode lock)
     - Releases: inode_locks[found_target_ino-1]
     - Calls free_inode(): inode_bitmap_lock held briefly
   - Else:
     - Releases: inode_locks[found_target_ino-1]

ext2_fsal_cp:
1. OPTIMISTIC PHASE (NO LOCKS):
   - open() source file on host filesystem
   - resolve_copy_destination() using path_lookup()
   - check_copy_target() using find_dir_entry()
   
2. HANDLE EXISTING TARGET (if overwriting):
   - free_inode_blocks_locked(): acquires inode_locks[target_ino-1], 
     calls free_block() (block_bitmap_lock), releases inode lock
   
3. ALLOCATE NEW INODE (BITMAP LOCK):
   - alloc_inode(): inode_bitmap_lock held briefly
   
4. WRITE FILE DATA (BLOCK LOCKS - brief, sequential):
   - write_data_into_inode() internally:
     - alloc_block(): block_bitmap_lock held briefly
     - write_block(): block_locks[block_num-1] held briefly
   
5. WRITE INODE (SINGLE LOCK):
   - write_inode(use_ino, &new_inode): inode_locks[use_ino-1] held briefly
   
6. ADD ENTRY (if new file) via add_dir_entry() (NESTED LOCKS):
   - Acquires: inode_locks[parent_ino-1]
   - Re-verifies: parent is directory, name doesn't exist
   - Acquires: block_locks[block_num-1] (nested)
   - Adds directory entry
   - Releases: block_locks[block_num-1]
   - Releases: inode_locks[parent_ino-1]

7. ON FAILURE - CLEANUP (BITMAP LOCKS):
   - free_inode_blocks_locked(): inode lock + block_bitmap_lock
   - free_inode(): inode_bitmap_lock held briefly

ext2_fsal_ln_sl:
1. OPTIMISTIC PHASE (NO LOCKS):
   - split_parent_name(dst) and path_lookup(parent)
   - find_dir_entry() to check if name exists
   
2. ALLOCATE (BITMAP LOCKS - brief, non-nested):
   - alloc_inode(): inode_bitmap_lock held briefly
   - alloc_block(): block_bitmap_lock held briefly
   
3. WRITE SYMLINK DATA (NO LOCKS - direct memcpy to new block):
   - get_block(new_block) and memcpy (block is newly allocated, not visible yet)
   
4. WRITE INODE (SINGLE LOCK):
   - write_inode(new_ino, &new_inode): inode_locks[new_ino-1] held briefly
   
5. ADD ENTRY via add_dir_entry() (NESTED LOCKS):
   - Acquires: inode_locks[parent_ino-1]
   - Re-verifies: parent is directory, name doesn't exist
   - Acquires: block_locks[block_num-1] (nested)
   - Adds symlink entry
   - Releases: block_locks[block_num-1]
   - Releases: inode_locks[parent_ino-1]

6. ON FAILURE - CLEANUP (BITMAP LOCKS):
   - free_block(): block_bitmap_lock held briefly
   - free_inode(): inode_bitmap_lock held briefly

Benefits of Optimistic Locking Approach
---------------------------------------
1. HIGH CONCURRENCY: Read-only path lookups proceed in parallel
2. LOW CONTENTION: Locks held only during actual modifications
3. EFFICIENT FAILURE: Failed validations just release locks (no rollback)
4. CORRECT UNDER RACES: Re-verification catches all concurrent modifications
5. NO DEADLOCKS: Consistent lock ordering + brief bitmap lock holds

Summary
-------
The optimistic locking design allows the ext2 filesystem to handle concurrent
operations correctly by:
- Performing initial checks without locks (fast, parallel reads)
- Re-verifying conditions after acquiring locks (catch races)
- Holding locks for minimal time (maximize concurrency)
- Using preemptive operations where needed (e.g., increment link count before
  adding directory entry to prevent deletion race)

This approach correctly handles the key race conditions:
- Two concurrent mkdir for same path -> one succeeds, one gets EEXIST
- Delete parent while creating child -> child creation fails with ENOENT  
- Hard link to file being deleted -> either link succeeds or fails cleanly
