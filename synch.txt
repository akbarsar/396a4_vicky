Synchronization Design Document for ext2 File System Operations
================================================================

Overview
--------
This document describes the synchronization strategy used to ensure thread-safe
concurrent access to the ext2 file system data structures. The design uses an
OPTIMISTIC LOCKING approach combined with fine-grained locks to maximize 
concurrency while preventing race conditions and deadlocks.

Key Design Principle: Optimistic Locking
----------------------------------------
The synchronization strategy follows an optimistic locking pattern:

1. OPTIMISTIC PHASE (Lock-Free): Perform initial lookups, path resolution,
   and validation checks WITHOUT holding any locks. This allows maximum
   concurrency during the read-heavy portion of operations.

2. VALIDATION PHASE (Locked): After acquiring the necessary locks, RE-VERIFY
   all conditions that were checked during the optimistic phase. This catches
   any concurrent modifications that occurred between the initial check and
   lock acquisition.

3. MODIFICATION PHASE (Locked): Apply changes while holding appropriate locks.

4. CLEANUP: If validation fails, release locks and return appropriate error.

This approach is more efficient than pessimistic locking because:
- Most operations succeed without contention
- Locks are held for minimal time
- Failed operations don't waste resources on rollback

Shared Data Structures
----------------------
The following data structures are shared among concurrent file system operations:

1. Superblock (superblock): Contains file system metadata including free block
   and inode counts.

2. Group Descriptor (group_desc): Contains block group metadata including
   free counts and directory count.

3. Inode Bitmap (inode_bitmap): Bitmap tracking allocated/free inodes.

4. Block Bitmap (block_bitmap): Bitmap tracking allocated/free blocks.

5. Inode Table (inode_table): Array of all inodes in the file system.

6. Data Blocks: Actual data blocks on the disk, accessed via mmap.

Synchronization Primitives
--------------------------
We use the following locks to protect shared data:

1. inode_bitmap_lock (pthread_mutex_t):
   - Protects the inode bitmap and inode-related counts in superblock/group_desc
   - Must be held when allocating or freeing inodes
   - Held only briefly during bitmap operations

2. block_bitmap_lock (pthread_mutex_t):
   - Protects the block bitmap and block-related counts in superblock/group_desc
   - Must be held when allocating or freeing blocks
   - Held only briefly during bitmap operations

3. inode_locks[] (array of pthread_mutex_t):
   - One lock per inode (indexed by inode number - 1)
   - Protects individual inode structure contents
   - Used during validation phase to re-check conditions

4. block_locks[] (array of pthread_mutex_t):
   - One lock per block (indexed by block number - 1)
   - Protects individual block contents
   - Used when modifying directory entries within a block

Race Condition Handling
-----------------------

1. TWO CONCURRENT MKDIR REQUESTS for same path (e.g., mkdir "/foo" x2):
   
   Strategy: add_dir_entry() implements optimistic locking with re-verification
   
   - Thread A: Checks if "/foo" exists (not found), allocates inode/block
   - Thread B: Same checks, allocates different inode/block
   - Thread A: Acquires parent inode lock, RE-CHECKS if "foo" exists
     - If still not found: creates entry, succeeds
   - Thread B: Acquires parent inode lock, RE-CHECKS if "foo" exists
     - Now found (created by A): returns EEXIST, frees allocated resources
   
   Implementation in add_dir_entry():
     mutex_lock(&inode_locks[parent_inode - 1]);
     // re-verify: check if name already exists after acquiring lock
     int existing = find_dir_entry(dir_inode, name);
     if (existing >= 0) {
         mutex_unlock(&inode_locks[parent_inode - 1]);
         return EEXIST;
     }

2. DELETE /foo WHILE RUNNING mkdir /foo/bar:
   
   Strategy: add_dir_entry() re-verifies parent is still valid
   
   - Thread A: mkdir /foo/bar - looks up /foo, gets inode
   - Thread B: rm /foo or rmdir - starts deletion
   - Thread A: Tries to add "bar" to /foo
     - Acquires /foo's inode lock
     - RE-VERIFIES /foo is still a valid directory (checks i_mode)
     - If parent was deleted/corrupted: returns ENOENT
   
   Implementation in add_dir_entry():
     mutex_lock(&inode_locks[parent_inode - 1]);
     // re-verify: parent is still a valid directory after acquiring lock
     if (!S_ISDIR(dir_inode->i_mode)) {
         mutex_unlock(&inode_locks[parent_inode - 1]);
         return ENOENT;
     }

3. HARD LINK TO CONCURRENTLY DELETED FILE:
   
   Strategy: ln_hl locks source inode and re-verifies before incrementing link count
   
   - Thread A: ln_hl /file /link - looks up /file, gets source inode
   - Thread B: rm /file - starts deletion, decrements link count
   - Thread A: Before creating link
     - LOCKS source inode FIRST (prevents deletion from completing)
     - RE-VERIFIES source inode is still valid:
       * checks links_count > 0
       * checks dtime == 0 (not deleted)
       * checks not a directory
     - If valid: increments link count, then adds directory entry
     - If invalid (deleted): returns ENOENT
   
   Implementation in ext2_fsal_ln_hl():
     mutex_lock(&inode_locks[src_ino - 1]);
     // re-verify source inode is still valid after acquiring lock
     if (src_inode->i_links_count == 0 || src_inode->i_dtime != 0) {
         mutex_unlock(&inode_locks[src_ino - 1]);
         return ENOENT;
     }
     // increment BEFORE releasing lock (prevents deletion race)
     src_inode->i_links_count++;
     mutex_unlock(&inode_locks[src_ino - 1]);
     // now safe to add directory entry

4. CONCURRENT REMOVE with NAME CHANGE:
   
   Strategy: rm uses the inode found DURING locked search, not initial lookup
   
   - rm operation searches for entry BY NAME while holding parent lock
   - Uses found_target_ino from the locked search, not the pre-lookup
   - Re-verifies target is not a directory before removal
   
   Implementation in ext2_fsal_rm():
     mutex_lock(&inode_locks[parent_ino - 1]);
     // search and remove by NAME, storing actual inode found
     found_target_ino = entry->inode;
     // re-verify: check if the found entry is a directory
     if (S_ISDIR(found_inode->i_mode)) {
         // cannot remove directories with rm
         return EISDIR;
     }

LOCK ACQUISITION STRATEGY
-------------------------

Lock Usage
~~~~~~~~~~
The list below describes when each lock is required:

Inode Bitmap Lock (inode_bitmap_lock):
  Used in:
    - alloc_inode(): Lock -> find free inode -> mark used -> update counts -> unlock
    - free_inode(): Lock -> mark free -> update counts -> unlock
  Purpose: Protects inode bitmap and free inode counts in superblock/group_desc.
  Always held only briefly (non-nested).

Block Bitmap Lock (block_bitmap_lock):
  Used in:
    - alloc_block(): Lock -> find free block -> mark used -> update counts -> unlock
    - free_block(): Lock -> mark free -> update counts -> unlock
  Purpose: Protects block bitmap and free block counts.
  Also held briefly (non-nested).

Per-Inode Locks (inode_locks[]):
  Held when:
    - Reading/modifying any inode fields (e.g., links_count, i_mode)
    - Writing new inode metadata via write_inode()
    - Changing link counts in ln_hl, rm, mkdir
    - Validating inode state after optimistic lookup
  Index: inode_locks[inode_number - 1]

Per-Block Locks (block_locks[]):
  Held during:
    - Writing or updating file/directory data via write_block()
    - Modifying directory entries (adding/removing entries in add_dir_entry, rm)
    - Initializing new directory blocks
  Index: block_locks[block_number - 1]

Lock Ordering (Deadlock Prevention)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The actual lock ordering varies by operation, but follows these principles:

1. BITMAP LOCKS are always non-nested and brief:
   - Never held while acquiring inode or block locks
   - Acquired and released atomically within alloc/free functions

2. For DIRECTORY OPERATIONS (add_dir_entry, rm):
   - Parent directory inode lock FIRST
   - Parent directory data block locks SECOND (while holding parent inode lock)
   - Unlock in reverse order: block first, then parent inode

3. TARGET INODE is locked SEPARATELY (not nested with parent):
   - In rm: Parent is fully unlocked before locking target inode
   - In mkdir: Parent lock for link count update is separate from add_dir_entry

4. SPECIAL CASE for ln_hl:
   - Source inode lock FIRST (to prevent deletion race)
   - Unlock source BEFORE calling add_dir_entry
   - Parent locks handled independently by add_dir_entry

Unlocking Strategy
~~~~~~~~~~~~~~~~~~
We unlock immediately after finishing with each resource:
- Block locks released before parent inode lock (reverse order)
- No circular dependencies because:
  * Bitmap locks never overlap with inode/block locks
  * Target inode locked only after parent is released (in rm)
  * ln_hl releases source lock before acquiring parent locks

Operation-Specific Synchronization
----------------------------------

ext2_fsal_mkdir:
1. OPTIMISTIC: Parse path, lookup parent, check if name exists
2. ALLOCATE: Get new inode and block (bitmap locks held briefly)
3. PREPARE: Initialize inode and block (no locks needed for new resources)
4. VALIDATE & MODIFY: 
   - add_dir_entry: Lock parent -> re-verify name doesn't exist -> add entry
5. UPDATE: Lock parent inode -> increment link count -> unlock

ext2_fsal_ln_hl:
1. OPTIMISTIC: Lookup source, check it's not a directory, lookup dest parent
2. VALIDATE SOURCE: Lock source inode -> re-verify valid (links>0, dtime=0)
3. PREEMPTIVE INCREMENT: Increment link count BEFORE adding entry (prevents deletion)
4. ADD ENTRY: add_dir_entry handles parent locking and re-verification
5. ROLLBACK if needed: On failure, lock source -> decrement link count -> unlock

ext2_fsal_rm:
1. OPTIMISTIC: Lookup parent, find target, verify not a directory
2. LOCK PARENT: Acquire parent inode lock
3. RE-VERIFY: Confirm parent is still a directory
4. SEARCH & REMOVE: 
   - Lock each block while searching
   - Find entry by NAME (not pre-looked-up inode)
   - Re-verify target is not a directory
   - Remove entry from block
5. UNLOCK PARENT
6. UPDATE TARGET: Lock target inode -> decrement link count
7. CLEANUP: If links == 0, free blocks and inode

ext2_fsal_cp:
1. OPTIMISTIC: Open source, lookup dest parent, check for existing
2. ALLOCATE: Get new inode (or reuse if overwriting)
3. WRITE DATA: Allocate and write blocks (brief block locks via write_block)
4. ADD ENTRY: If new file, use add_dir_entry (handles locking)
5. If overwriting: Lock target -> free old blocks -> write new data -> unlock

ext2_fsal_ln_sl:
1. OPTIMISTIC: Lookup parent directory
2. ALLOCATE: Get new inode and block for symlink
3. WRITE: Store path in block (via write_block with lock)
4. ADD ENTRY: Use add_dir_entry (handles parent locking)

Benefits of Optimistic Locking Approach
---------------------------------------
1. HIGH CONCURRENCY: Read-only path lookups proceed in parallel
2. LOW CONTENTION: Locks held only during actual modifications
3. EFFICIENT FAILURE: Failed validations just release locks (no rollback)
4. CORRECT UNDER RACES: Re-verification catches all concurrent modifications
5. NO DEADLOCKS: Consistent lock ordering + brief bitmap lock holds

Summary
-------
The optimistic locking design allows the ext2 filesystem to handle concurrent
operations correctly by:
- Performing initial checks without locks (fast, parallel reads)
- Re-verifying conditions after acquiring locks (catch races)
- Holding locks for minimal time (maximize concurrency)
- Using preemptive operations where needed (e.g., increment link count before
  adding directory entry to prevent deletion race)

This approach correctly handles the key race conditions:
- Two concurrent mkdir for same path -> one succeeds, one gets EEXIST
- Delete parent while creating child -> child creation fails with ENOENT  
- Hard link to file being deleted -> either link succeeds or fails cleanly
